"""
Name: James Reed
Date: 11/02/2025
Assignment: Assignment 4
Due Date: 11/04/2025
About this project: telnet chat & chat rooms server
Assumptions: assumes correct user input and no network issues.
All work below was performed solely by Jimmy.
I did use code generated by an AI tool.
"""

import os
import json 
import time
import sys


from socket import socket, gethostname
from threading import Thread, Lock

GOODBYEMSGFILE = "./goodbye.txt"
BEFORELOGINMSGFILE = "./prelogin.txt"
WELCOMEMSGFILE = "./welcome.txt"
HELP_TEXT = (
    "Commands supported ([] optional field, <> required field): \n"
    " \n"
    " who                    # List all online users \n"
    " status [user]          # Display user information \n"
    " start <topic>          # Start a room for a topic \n"
    " rooms                  # List all current rooms \n"
    " join <room_num>        # Join a room \n"
    " leave <room_num>       # Leave a room \n"
    " shout <msg>            # Broadcast <msg> to everyone online \n"
    " tell <user> <msg>      # Tell <msg> only to the user \n"
    " info [info_text]       # Change or show your information text \n"
    " quit                   # Logout \n"
    " exit                   # Logout \n"
    " block <user>           # block a user \n"
    " unblock <user>         # unblock a user \n"
    " say <room_num> <msg>   # Broadcast <msg> to everyone in <room_num> \n"
    " help                   # Print this message \n"
    " register <user> <pwd>  # Register a new user \n\n"
)

USER_DB = "./users.json"
BLOCK_DB = "./blocks.json"

beforeLoginMsg = ''
goodbyeMsg = ''

def loadMsgs():
    global beforeLoginMsg
    global goodbyeMsg
    global welcomeMsg
    
    with open(BEFORELOGINMSGFILE, "r") as f:
        beforeLoginMsg = f.read()
    with open(GOODBYEMSGFILE, "r") as f:
        goodbyeMsg = f.read()
    with open(WELCOMEMSGFILE, "r") as f:
        welcomeMsg = f.read()
                
n = len(sys.argv)
if (n != 2):
    print("Usage: server_port")
    exit()

loadMsgs()

users = {} # Dict: username -> user dict
online_users = {}
blocks = {} # Dict: username -> list of blocked
data_lock = Lock() # Protects from race conditions
rooms = {}
room_seq = 1 # next room id

def load_data():
    """Load users and blocks from files at startup"""
    global users, blocks
    
    try:
        with open('users.json', 'r') as f:
            users = json.load(f)
    except FileNotFoundError:
        users = {}
    
    try: 
        with open('blocks.json', 'r') as f:
            blocks = json.load(f)
    except FileNotFoundError:
        blocks = {}
    
    print("data loaded from files")

def save_data():
    """Saves user and blocks to JSON"""
    with data_lock:
        with open('users.json', 'w') as f: 
            json.dump(users, f, indent=4)
        with open('blocks.json', 'w') as f:
            json.dump(blocks, f, indent=4)

load_data()

class User:
    def __init__(self, username, sock, is_guest=True) -> None:
        self.username = username
        self.sock = sock
        self.is_guest = is_guest
        self.rooms = set() # Set of room IDs the user is in
        self.info = "" # user info text
        self.blocked = set() # Set of blocked users

        with data_lock:
            if username in users and users[username].get("password"):
                self.is_guest = False
                self.info = users[username].get("info", "")
                self.blocked = set(blocks.get(username, []))
                users[username]["online"] = True
                online_users[username] = self
                blocks.setdefault(username, list(self.blocked))
            else:
                # GUEST SESSION
                self.is_guest = True

        if not self.is_guest:
            save_data()

        print(f"User: {self.username} logged in (guest: {self.is_guest})")
    
    def logout(self):
        """cleanup on disconnect"""
        with data_lock:
            if self.username in users:
                users[self.username]["online"] = False
                del online_users[self.username]
        self.rooms.clear()
        try:
            self.sock.close()
        except:
            pass
        save_data()

class Room:
    def __init__(self, topic, leader) -> None:
        global room_seq
        with data_lock:
            self.id = room_seq
            room_seq += 1
        self.topic = topic
        self.leader = leader
        self.members = set([leader.username])
        leader.rooms.add(self.id)
        print(f"Room {self.id} started {topic} by {leader.username}")

    def add_member(self, user):
        self.members.add(user.username)
        user.rooms.add(self.id)

    def remove_member_old(self, user):
        should_close = False
        with data_lock:
            if self.id not in rooms:
                raise ValueError("Room does not exist")
            was_leader = (self.leader and user.username == self.leader.username)
            self.members.discard(user.username)
            user.rooms.discard(self.id)
            should_close = was_leader or not self.members
            if should_close:
                del rooms[self.id]
                close_msg = f"!!system!!: Room {self.id}(topic: {self.topic}) closed\n"
        if close_msg: broadcast_online(close_msg)

    def remove_member(self, user):
        close_msg = None
        should_close = None
        with data_lock:
            if self.id not in rooms:
                raise ValueError("Room does not exist")
            was_leader = (self.leader and user.username == self.leader.username)
            self.members.discard(user.username)
            user.rooms.discard(self.id)
            should_close = was_leader or not self.members
            if should_close:
                # Optional: clean membersâ€™ room sets for consistency
                for name in list(self.members):
                    u = online_users.get(name)
                    if u:
                        u.rooms.discard(self.id)
                self.members.clear()
                del rooms[self.id]
                close_msg = f"!!system!!: Room {self.id}(topic: {self.topic}) closed\n"
        if close_msg:
            broadcast_online(close_msg)




def process_cmd(user: User, cmd_str, cmd_count):
    parts = cmd_str.split()
    if not parts:
        mySendAll(user.sock, "Empty command.\n".encode())
        return
    command = parts[0].lower()
    args = parts[1:]

    # Checks guest entered permissed commands
    if user.is_guest and command:
        allowed_commands = {
            'register': cmd_register,
            'exit': lambda u, a: cmd_quit(u),
            'quit': lambda u, a: cmd_quit(u),
        }
        if command not in allowed_commands:
            mySendAll(sock, "You are logged in as a guest. The only commands that you can user are \n"
                    "'register username password', 'exit', and 'quit'. \n".encode()) 
            return

    handlers = {
        'who': cmd_who,
        'status': cmd_status,
        'start': cmd_start,
        'rooms': cmd_rooms,
        'join': cmd_join,
        'leave': cmd_leave,
        'shout': cmd_shout,
        'tell': cmd_tell,
        'info': cmd_info,
        'quit': lambda u, a: cmd_quit(u),
        'exit': lambda u, a: cmd_quit(u),
        'block': cmd_block,
        'unblock': cmd_unblock,
        'say': cmd_say,
        'help': cmd_help,
        'register': cmd_register,
        # Default
    }
    handler = handlers.get(command, cmd_unknown)
    try:
        result = handler(user, args)
        return bool(result)
    except ValueError as e:
        mySendAll(user.sock, f"Error: {e}\n".encode())
        return False
    except Exception as e:
        print(f"Unhandled in {user.username}: {e}")
        return False

def cmd_help(user, args):
    mySendAll(user.sock, HELP_TEXT.encode())

def cmd_who(user, args):
    with data_lock:
        online = list(online_users.keys())
    msg = "online users: " + ", ".join(online) + "\n"
    mySendAll(user.sock, msg.encode())

def cmd_status(user, args):
    target = args[0] if args else user.username
    with data_lock:
        if target not in users:
            raise ValueError("User does not exist")
        info = users[target].get("info", "No info")
    msg = f"{target}'s status: {info}\n"
    mySendAll(user.sock, msg.encode())

def cmd_start(user, args):
    if len(args) < 1:
        raise ValueError("missing args")
    topic = " ".join(args)
    if any(r.topic == topic for r in rooms.values()):
        raise ValueError("topics exists")
    new_room = Room(topic, user)
    with data_lock: 
        rooms[new_room.id] = new_room
    mySendAll(user.sock, f"Started room {new_room.id}: {topic}\n".encode())

def cmd_rooms(user, args):
    if not rooms:
        mySendAll(user.sock, "No active rooms\n".encode())
        return
    msg = "Active rooms:\n"
    with data_lock:
        snapshot = list(rooms.items())
    for rid, room in snapshot:
        participants = ", ".join(sorted(room.members))
        msg += (f"Room {rid}: , topic: {room.topic}\n"
                f"{len(room.members)} Participant(s): {participants}\n\n")
    mySendAll(user.sock, msg.encode())

def cmd_join(user, args):
    if len(args) != 1 or not args[0].isdigit():
        raise ValueError("Incorrect format: join <room number>")
    room_id = int(args[0])
    with data_lock:
        if room_id not in rooms:
            raise ValueError("Room does not exist")
        room = rooms[room_id]
        if user.username in room.members:
            mySendAll(user.sock, f"You are already in Room {room_id}.\n".encode())
            return 
        room.add_member(user)
    mySendAll(user.sock, f"You joined Room {room_id}.\n".encode())

def cmd_leave(user, args):
    if len(args) != 1 or not args[0].isdigit():
        raise ValueError("Incorrect format")
    room_id = int(args[0])
    with data_lock:
        if room_id not in rooms:
            raise ValueError("Room does not exist")
        room = rooms[room_id]
        if user.username not in room.members:
            raise ValueError("You must join the room")
    room.remove_member(user)
    mySendAll(user.sock, f"Left room {room_id}.\n".encode())

def broadcast_online(msg, exclude=None, sender=None):
    # Convert to bytes if needed
    msg_bytes = msg.encode() if isinstance(msg, str) else msg
    with data_lock:
        targets = [
            uobj for uname, uobj in online_users.items()
                if uname != exclude and not (sender and sender.username in uobj.blocked)
        ]
    for uobj in targets:
        mySendAll(uobj.sock, msg_bytes)

def cmd_shout(user, args):
    if not args:
        raise ValueError("No Message")
    msg = f"*{user.username} shouts: {' '.join(args)}*\n"
    broadcast_online(msg, sender=user)

def cmd_tell(user, args):
    if len(args) < 2:
        raise ValueError("Incorrect format")
    target = args[0]
    message = " ".join(args[1:])
    with data_lock:
        if target not in online_users:
            raise ValueError("User is not online")
        targ_usr = online_users[target]
        if user.username in targ_usr.blocked:
            mySendAll(user.sock, f"Message blocked by {target}.\n".encode())
            return
    msg = f"{user.username} tells you {message}\n"
    mySendAll(targ_usr.sock, msg.encode())
    mySendAll(user.sock, f"Told {target}.\n".encode())

def cmd_info(user, args):
    if not args:
        mySendAll(user.sock, f"Your info: {user.info}\n".encode())
        return
    new_info = " ".join(args)
    user.info = new_info
    with data_lock:
        if user.username in users:
            users[user.username]["info"] = new_info
    save_data()
    mySendAll(user.sock, "Info updated\n".encode())

def cmd_quit(user):
    mySendAll(user.sock, goodbyeMsg.encode())
    return True

def cmd_block(user, args):
    if len(args) != 1:
        raise ValueError("Incorrect format")
    target = args[0]
    if target not in users:
        raise ValueError("User does not exist")
    user.blocked.add(target)
    with data_lock:
        blocks[user.username] = list(user.blocked)
    save_data()
    mySendAll(user.sock, f"Blocked {target}.\n".encode())

def cmd_unblock(user, args):
    if len(args) != 1:
        raise ValueError("Incorrect format")
    target = args[0]
    if target not in users:
        raise ValueError("User does not exist")
    user.blocked.discard(target)
    with data_lock:
        blocks[user.username] = list(user.blocked)
    save_data()
    mySendAll(user.sock, f"Unblocked {target}.\n".encode())

def cmd_say(user, args):
    if len(args) < 2:
        raise ValueError("Incorrect Format")
    room_id = int(args[0]) if args[0].isdigit() else -1
    msg = " ".join(args[1:])
    with data_lock:
        if room_id not in rooms:
            raise ValueError("Room does not exist")
        room = rooms[room_id]
        if user.username not in room.members:
            raise ValueError("Not in room")
        msg = f"{user.username} in {room.topic}: {msg}\n"
        for mem in room.members:
            mem_usr = online_users.get(mem)
            if mem_usr and user.username not in mem_usr.blocked:
                mySendAll(mem_usr.sock, msg.encode())

def cmd_register(user, args):
    if len(args) < 2:
        raise ValueError("Incorrect format: register <user> <password>")
    new_user, passwd = args[0], args[1]
    with data_lock:
        if new_user in users:
            raise ValueError("User already exists")
        users[new_user] = {"password": passwd, "info": "", "online": False}
    save_data()
    mySendAll(user.sock, f"Registered new user '{new_user}'\n".encode())

def cmd_unknown(user, args):
    mySendAll(user.sock, "Unsupported command. Type 'help' for list.\n".encode())


"""
Send all data to sock, return 1 if successful
-1 if failed (socket error)
"""
def mySendAll(sock, data):
    total_sent = 0
    data_length = len(data)

    try:
        while total_sent < data_length:
            sent = sock.send(data[total_sent:])
            if sent == 0:
                # Socket connection broken
                return -1
            total_sent += sent

    except OSError:
        print("Socket send error.")
        return -1 

    return 1

def processCmd(userName, sock, cmd):
    print(f"process '{cmd}' from {userName}")

    # perform according to the cmd, echo for now
    mySendAll(sock, f"Server response to '{cmd}'\n".encode())

def handleOneClient(sock):

    mySendAll(sock, beforeLoginMsg.encode())
    mySendAll(sock, "Enter your username: ".encode())

    data1 = sock.recv(1000).decode().strip()
    if not data1:
        sock.close()
        return
    username = data1.split()[0] # First word as username
    password = None 
    if username in users and users[username]["password"]:
        mySendAll(sock, "Enter your password: ".encode())
        pass_data = sock.recv(1000).decode().strip()
        if pass_data != users[username]["password"]:
            mySendAll(sock, "Login error: Invalid password.\n".encode())
            sock.close()
            return 
        password = pass_data

    
    user = User(username, sock, is_guest=(password is None))
    cmdCount = 0

    mySendAll(sock, welcomeMsg.encode())

    if user.is_guest:
        mySendAll(sock, "You are logged in as a guest. The only commands that you can user are \n"
                  "'register username password', 'exit', and 'quit'. \n".encode())
        user.username = "guest"
        username = "guest"
    else:
        mySendAll(sock, HELP_TEXT.encode())

    mySendAll(sock, f"<{user.username}:{cmdCount}> ".encode())
    
    while True:
        try:
            data = sock.recv(1000).decode().strip()
            if not data:
                print(f"Client {username} disconnected")
                break
            cmdCount += 1
            # Route command to the real dispatcher with the User object
            should_quit = process_cmd(user, data, cmdCount)
            if should_quit: break
            # Reprint prompt after each command
            mySendAll(sock, f"<{user.username}:{cmdCount}> ".encode())
        except Exception as e:
            print(f"Error in {username}: {e}")
            break
    user.logout() # cleanup 

s = socket()
print(sys.argv[0], sys.argv[1])

# Bind to localhost so tests connecting to 127.0.0.1/localhost work
s.bind(("127.0.0.1", int(sys.argv[1])))
s.listen(5)
        
while True:
    sock, addr = s.accept()
    print("Receive client connection from ", addr)
    p = Thread(target=handleOneClient, args=(sock,), daemon = True)

    # The server crashes and doesn't close appropriately
    # TODO: add a try catch to stop the program safely 
    p.start()
    
