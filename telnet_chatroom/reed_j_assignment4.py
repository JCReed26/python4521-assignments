"""
Name: James Reed
Date: 11/02/2025
Assignment: Assignment 4
Due Date: 11/04/2025
About this project: telnet chat & chat rooms server
Assumptions: assumes correct user input and no network issues.
All work below was performed solely by Jimmy.
I did use code generated by an AI tool.
"""

import os
import json 
import time
import sys


from socket import socket, gethostname
from threading import Thread, Lock

GOODBYEMSGFILE = "./goodbye.txt"
BEFORELOGINMSGFILE = "./prelogin.txt"

USER_DB = "./users.json"
BLOCK_DB = "./blocks.json"

beforeLoginMsg = ''
goodbyeMsg = ''

def loadMsgs():
    global beforeLoginMsg
    global goodbyeMsg
    
    with open(BEFORELOGINMSGFILE, "r") as f:
        beforeLoginMsg = f.read()
    with open(GOODBYEMSGFILE, "r") as f:
        goodbyeMsg = f.read()
                
n = len(sys.argv)
if (n != 2):
    print("Usage: server_port")
    exit()

loadMsgs()

users = {} # Dict: username -> user dict
online_users = {}
blocks = {} # Dict: username -> list of blocked
data_lock = Lock() # Protects from race conditions
rooms = {}

def load_data():
    """Load users and blocks from files at startup"""
    global users, blocks
    
    try:
        with open('users.json', 'r') as f:
            users = json.load(f)
    except FileNotFoundError:
        users = {}
    
    try: 
        with open('blocks.json', 'r') as f:
            blocks = json.load(f)
    except FileNotFoundError:
        blocks = {}
    
    print("data loaded from files")

def save_data():
    """Saves user and blocks to JSON"""
    with data_lock:
        with open('users.json', 'w') as f: 
            json.dump(users, f, indent=4)
        with open('blocks.json', 'w') as f:
            json.dump(blocks, f, indent=4)

load_data()

class User:
    def __init__(self, username, sock, is_guest=True) -> None:
        self.username = username
        self.sock = sock
        self.is_guest = is_guest
        self.rooms = set() # Set of room IDs the user is in
        self.info = "" # user info text
        self.blocked = set() # Set of blocked users

        with data_lock:
            if username in users:
                self.is_guest = False
                self.info = users[username].get("info", "")
                self.blocked = set(blocks.get(username, [])) # gets list of users blocked by the curr user
            else:
                users[username] = {"password": None, "info": "", "online": True}
                self.is_guest = True
            users[username]["online"] = True
            online_users[username] = self
            blocks[username] = list(self.blocked)
        save_data()
        print(f"User: {username} logged in (guest: {is_guest})")
    
    def logout(self):
        """cleanup on disconnect"""
        with data_lock:
            if self.username in users:
                users[self.username]["online"] = False
                del online_users[self.username]
        self.rooms.clear()
        try:
            self.sock.close()
        except:
            pass
        save_data()

class Room:
    def __init__(self, topic, leader) -> None:
        self.id = id(self)
        self.topic = topic
        self.leader = leader
        self.members = set([leader.username])
        leader.rooms.add(self.id)
        print(f"Room {self.id} started {topic} by {leader.username}")

    def add_member(self, user):
        self.members.add(user.username)
        user.rooms.add(self.id)

    def remove_member(self, user):
        self.members.discard(user.username)
        user.rooms.discard(self.id)
        if user.username == self.leader.username or not self.members: 
            self.close()
    
    def close(self):
        msg = f"Room {self.id} closed \n"
        for mem_name in list(self.members):
            pass # find online user and send implement broadcast helper later
        with data_lock:
            if self.id in rooms:
                del rooms[self.id]

def process_cmd(user, cmd_str, cmd_count):
    parts = cmd_str.split()
    if not parts:
        mySendAll(user.sock, "Empty command.\n".encode())
        return
    command = parts[0].lower()
    args = parts[1:]

    handlers = {
        'who': cmd_who,
        'status': cmd_status,
        'start': cmd_start,
        'rooms': cmd_rooms,
        'join': cmd_join,
        'leave': cmd_leave,
        'shout': cmd_shout,
        'tell': cmd_tell,
        'info': cmd_info,
        'quit': lambda u, a: cmd_quit(u),
        'exit': lambda u, a: cmd_quit(u),
        'block': cmd_block,
        'unblock': cmd_unblock,
        'say': cmd_say,
        'help': cmd_help,
        'register': cmd_register,
        # Default
    }
    handler = handlers.get(command, cmd_unknown)
    try:
        handler(user, args)
    except ValueError as e:
        mySendAll(user.sock, f"Error: {e}\n".encode())
    except Exception as e:
        print(f"Unhandled in {user.username}: {e}")

def cmd_help(user, args):
    help_text = "" + \
    "who                    # List all online users" + \
    "status [user]          # " + \
    "start <topic>          # " + \
    "rooms                  # List all current rooms" + \
    "join <room_num>        # " + \
    "leave <room_num>       # " + \
    "shout <msg>            # " + \
    "tell <user> <msg>      # " + \
    "info [info_text]       # Change or show your information text" + \
    "quit                   # Logout" + \
    "exit                   # Logout" + \
    "block <user>           # block a user" + \
    "unblock <user>         # unblock a user" + \
    "say <room_num> <msg>   # Broadcast <msg> to everyone in <room_num>" + \
    "help                   # Print this message" + \
    "register <user> <pwd>  # Register a new user" + \
    "\n"
    mySendAll(user.sock, help_text.encode())

def cmd_who(user, args):
    with data_lock:
        online = [u for u, ud in users.items() if ud["online"]]
    msg = "online users: " + ", ".join(online) + "\n"
    mySendAll(user.sock, msg.encode())

def cmd_status(user, args):
    target = args[0] if args else user.username
    with data_lock:
        if target not in users:
            raise ValueError("User does not exist")
        info = users[target].get("info", "No info")
    msg = f"{target}: {info}\n"
    mySendAll(user.sock(), msg.encode())

def cmd_start(user, args):
    if len(args) < 1:
        raise ValueError("missing args")
    topic = " ".join(args)
    if any(rooms["topic"] == topic for r in rooms.values()):
        raise ValueError("topics exists")
    new_room = Room(topic, user)
    with data_lock: 
        rooms[new_room.id] = new_room
    mySendAll(user.sock(), f"Started room {new_room.id}: {topic}\n".encode())

def cmd_rooms(user, args):
    if not rooms:
        mySendAll(user.sock, "No rooms.\n".encode())
        return
    msg = "Rooms:\n"
    for rid, room in rooms.items():
        leader = room.leader.username if room.leader else "Closed"
        msg += f"{rid}: {room.topic} (leader: {leader}, members: {len(room.members)})\n"
    mySendAll(user.sock, msg.encode())

def cmd_join(user, args):
    if len(args) != 1 or not args[0].isdigit():
        raise ValueError("Incorrect format: join <room number>")
    room_id = int(args[0])
    with data_lock:
        if room_id not in rooms:
            raise ValueError("Room does not exist")
        room = rooms[room_id]
        if user.username in room.members:
            mySendAll(user.sock(), "Already in room.\n".encode())
            return 
        room.add_member(user)
    mySendAll(user.sock, f"Joined room {room_id}.\n".encode())

def cmd_leave(user, args):
    if len(args) != 1 or not args[0].isdigit():
        raise ValueError("Incorrect format")
    room_id = int(args[0])
    with data_lock:
        if room_id not in rooms:
            raise ValueError("Room does not exist")
        room = rooms[room_id]
        if user.username not in room.members:
            raise ValueError("Not in room")
        room.remove_member(user)
    mySendAll(user.sock, f"left room {room_id}.\n".encode())

def broadcast_online(msg, exclude=None, sender=None):
    with data_lock:
        for uname, uobj in online_users.items():
            if uname == exclude:
                continue
            if sender and uname in blocks.get(sender.username, []) or sender.username in uobj.blocked:
                continue 
            mySendAll(uobj.sock(), msg)

def cmd_shout(user, args):
    if not args:
        raise ValueError("No Message")
    msg = f"*{user.username} shouts: {' '.join(args)}*\n"
    broadcast_online(msg, sender=user)

def cmd_tell(user, args):
    if len(args) < 2:
        raise ValueError("Incorrect format")
    target = args[0]
    message = " ".join(args[1:])
    with data_lock:
        if target not in online_users:
            raise ValueError("User not online")
        targ_usr = online_users[target]
        if user.username in targ_usr.blocked:
            mySendAll(user.sock(), f"Message blocked by {target}.\n".encode())
            return
    msg = f"{user.username} tells you {message}\n"
    mySendAll(targ_usr.sock(), msg.encode())
    mySendAll(user.sock(), f"Told {target}.\n")

def cmd_info(user, args):
    pass

def cmd_quit(user):
    mySendAll(user.sock(), goodbyeMsg.encode())

def cmd_block(user, args):
    if len(args != 1):
        raise ValueError("Incorrect format")
    target = args[0]
    if target not in users:
        raise ValueError("User does not exist")
    user.blocked.add(target)
    with data_lock:
        blocks[user.username] = list(user.blocked)
    save_data()
    mySendAll(user.sock(), f"Blocked {target}.\n".encode())

def cmd_unblock(user, args):
    if len(args != 1):
        raise ValueError("Incorrect format")
    target = args[0]
    if target not in users:
        raise ValueError("User does not exist")
    user.blocked.discard(target)
    with data_lock:
        blocks[user.username] = list(user.blocked)
    save_data()
    mySendAll(user.sock(), f"Blocked {target}.\n".encode())

def cmd_say(user, args):
    if len(args) < 2:
        raise ValueError("Incorrect Format")
    room_id = args[0]
    msg = " ".join(args[1:])
    with data_lock:
        if room_id not in rooms:
            raise ValueError("Room does not exist")
        room = rooms[room_id]
        if user.username not in room.members:
            raise ValueError("Not in room")
        msg = f"{user.username} in {room.topic}: {msg}\n"
        for mem in room.members:
            mem_usr = online_users.get(mem)
            if mem_usr and user.username not in mem_usr.blocked:
                mySendAll(mem_usr.sock(), msg.encode())

def cmd_register(user, args):
    if len(args) < 2:
        raise ValueError("Incorrect format: register <user> <password>")
    new_user, passwd = args[0], args[1]
    with data_lock:
        if new_user in users:
            raise ValueError("User already exists")
        users[new_user] = {"password": passwd, "info": "", "online": False}
    save_data()
    mySendAll(user, f"Registed {new_user}.\n")

def cmd_unknown(user, args):
    mySendAll(user.sock(), "Unsupported command. Type 'help' for list.\n")


"""
Send all data to sock, return 1 if successful
-1 if failed (socket error)
"""
def mySendAll(sock, data):
    total_sent = 0
    data_length = len(data)

    try:
        while total_sent < data_length:
            sent = sock.send(data[total_sent:])
            if sent == 0:
                # Socket connection broken
                return -1
            total_sent += sent

    except OSError:
        print("Socket send error.")
        return -1 

    return 1

def processCmd(userName, sock, cmd):
    print(f"process '{cmd}' from {userName}")

    # perform according to the cmd, echo for now
    mySendAll(sock, f"Server response to '{cmd}'\n".encode())

def handleOneClient(sock):

    mySendAll(sock, beforeLoginMsg.encode())
    mySendAll(sock, "Enter your username: ".encode())

    data1 = sock.recv(1000).decode().strip()
    if not data1:
        sock.close()
        return
    username = data1.split()[0] # First word as username
    password = None 
    if username in users and users[username]["password"]:
        mySendAll(sock, "Enter password: ".encode())
        pass_data = sock.recv(1000).decode().strip()
        if pass_data != users[username]["password"]:
            mySendAll(sock, "Login error: Invalid password.\n".encode())
            sock.close()
            return 
        password = pass_data
    
    user = User(username, sock, is_guest=(password is None))

    str = f"Welcome to the Internet Chat Room, {username}!\n\n"
    mySendAll(sock, str.encode())
    if user.is_guest:
        mySendAll(sock, "You are logged in as a guest. Use 'registar <user> <password>' to create an account \n".encode())

    cmdCount = 0
    mySendAll(sock, f"<{username}:{cmdCount}> ".encode())
    
    while True:
        try:
            data = sock.recv(1000).decode().strip()
            if not data:
                print(f"Client {username} disconnected")
                break
            cmdCount += 1
            # Route command to the real dispatcher with the User object
            process_cmd(user, data, cmdCount)
            # Reprint prompt after each command
            mySendAll(sock, f"<{username}:{cmdCount}> ".encode())
        except Exception as e:
            print(f"Error in {username}: {e}")
            break
    user.logout() # cleanup 

s = socket()
h = gethostname()
print(sys.argv[0], sys.argv[1])

s.bind((h, int(sys.argv[1])))
s.listen(5)
        
while True:
    sock, addr = s.accept()
    print("Receive client connection from ", addr)
    p = Thread(target=handleOneClient, args=(sock,), daemon = True)
    p.start()
    
