COP4521 Homework 3

Name: James Reed         FSU login: jcr22e


1) (10 points) (True or False) By utilizing multiple processors, parallel
computing can make any sequential program run faster.

False. In theory yes it can and will speed up the program. But if there is no 
code section that can be run in parallel in the sequential program then 
utilizing multiple processors wont do anything


2) (10 points) Explain Flynn's classification of computing systems.

Flynns classification of computing systems is based upon parallelism in instruction
stream and parallelism in data stream. The four classifications are:
1. Single Instruction Single Data (SISD) - 1 time, 1 ins, 1 data 
2. Single Instruction Multiple Data (SIMD) - control unit gets instructions and 
    splits among processing units (matrix, vector machines, image and sound)
3. Multiple Instruction Multiple Data (MIMD) - multiple copies of SISD
4. Multiple Instruction Single Data (MISD) - not common, multiple instructions in multiple
    processing units that all use the same data


3) (20 points) Explain the relationship among multithreading, multiprocessing,
concurrent programming, and parallel programming.

Multithreading is concurreny through running multiple threads in a single process creating 'sub-processes'.
Multiprocessing can provide concurrency across multiple cores.
Concurrent programming is structuring a program to handle multiple tasks that make progress over time.
Parallel programming is the perfected version of currenecy by running multiple tasks all at the same time.


4) (20 points) Let a program have 20% sequential component and 80% that can
be parallelized. Given the strong scaling and weak scaling
speedups that can be achieved using 2, 4, 8, 16 processors.

strong (Amdahl): S(P) = 1 / (0.2 + 0.8/n)
  - n=2: 1 / (0.2 + 0.4) = 1.6667
  - n=4: 1 / (0.2 + 0.2) = 2.5
  - n=8: 1 / (0.2 + 0.1) = 3.3333
  - n=16: 1 / (0.2 + 0.05) = 4.0
weak (Gustafson): S(P) = 0.2 + 0.8 n
  - n=2: 1.8
  - n=4: 3.4
  - n=8: 6.6
  - n=16: 13.0


5) (20 points) Write a multiprocessing Python program that does the
following. The main process
initializes a message queue, starts a child process, sends a string 'start' to
the message queue, and waits for the child process to finish before it ends.
The child process reads from message queue, prints the message and exits. 

from multiprocessing import Process, Queue

def childprocess(queue):
    msg = queue.get()
    print(msg)

if __name__ == "__main__"":
    q = Queue()
    p = Process(target=childprocess, args=(q,))
    p.start()
    q.put("start")
    p.join()


6) (20 points) Parallelize the following loops using OpenMP

/* Loop 1 */ 
for (i=0; i<10000; i++) {
    a[i] = a[i+1] + 1.0;
} 
- you cannot parallelize this first loop because reading a[i+1] could be 
overwritten by another thread creates backwards dependencies across iterations

/* Loop 2 */
#pragma omp parallel for
for (i=0; i<10000; i++) {
    x = 2.0;
    a[i] = b[i] + c[i] + x;
}

/* Loop 3 */
#pragma omp parallel for reduction(+:x)
for (i=0; i<10000; i++) {
    y = a[i] + 2;
    x = x + y
}

/* Loop 4 */
#pragma omp parallel for reduction(+:a)
for(i=0; i<10000; i++) {
    for (j=0; j<10000; j++) {                                                       
        x = 2*i+1;                                                                  
        a = a + b[i]+x;                                                             
  }                                                                             
}