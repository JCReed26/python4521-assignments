"""
Name: James Reed
Date: 09/03/2025
Assignment: 1
Due Date: 09/12/2025
About this project: (write a small blurb about what this project's goals are/what tasks it accomplishes)
Assumptions: (write any assumptions made here (ex: assumes correct user input))
All work below was performed solely by (Your Name).
I [did not use | used] code generated by an AI tool.
"""

import sys
import random

# --- CONSTANTS ---
defect = 0
cooperate = 1
num_of_iterations = 2000    #default 2000
num_of_strategies = 8       #default 8

REWARDAMOUNTS = {
    (cooperate, cooperate): (3, 3),
    (cooperate, defect): (0, 5),
    (defect, cooperate): (5, 0),
    (defect, defect): (1, 1),
}

# --- HElPER FUNCTIONS ---
def get_reward_values(my_choice, opp_choice):
    return REWARDAMOUNTS[(my_choice, opp_choice)]

# definition given in instructions
def rangeReward(beg, end, p1_history, p2_history):
    """computes total rewards in the range of rounds from beg to end-1"""
    reward = 0
    for i in range(beg, end - 1):
        reward_amount, _ = get_reward_values(p1_history[i], p2_history[i])
        reward += reward_amount
    return reward

# --- Strategies ---
def strategy_alwaysCooperate(p1_history, p2_history):
    """always cooperates"""
    return cooperate

def strategy_alwaysDefect(p1_history, p2_history):
    """always defects"""
    return defect

def strategy_probAndLock(p1_history, p2_history):
    """Defect first 20, Cooperate second 20, till end choose higher yeilding option"""
    if (len(p1_history) < 20):
        return defect
    if (len(p1_history) < 40): 
        return cooperate
    else:
        reward20 = rangeReward(0, 20, p1_history, p2_history)
        reward40 = rangeReward(20, 40, p1_history, p2_history)
        if (reward20 > reward40):
            return defect
        else:
            return cooperate
        
def strategy_continuousProbe(p1_history, p2_history):
    """Defect, then cooperate, then choose based on average reward"""
    current_iteration = len(p1_history)
    if (current_iteration == 0):
        return defect
    if (current_iteration == 1):
        return cooperate
    else:
        cooperate_avg = 0
        defect_avg = 0
        cooperate_count = 0
        defect_count = 0

        for i in range(current_iteration):
            # get reward at i, check choice and add
            reward, _ = get_reward_values(p1_history[i], p2_history[i])
            if p1_history[i] == cooperate:
                cooperate_avg += reward
                cooperate_count += 1
            else:
                defect_avg += reward
                defect_count += 1
        
        return cooperate if cooperate_avg > defect_avg else defect

def strategy_defectUntilCooperate(p1_history, p2_history):
    """Defect until opponent cooperates"""
    if cooperate in p2_history:
        return cooperate
    else:
        return defect

def strategy_opponentCooperatePercentage(perc, p1_history, p2_history):
    """if opponent cooperates more than perc threshold then cooperate"""
    cooperate_count = 0 
    p2_choice_count = 0
    cooperate_avg = 0

    if p2_choice_count == 0:
        return defect
    else:
        for i in range(len(p2_history)):
            if p2_history[i] == cooperate:
                cooperate_count += 1
            p2_choice_count += 1
        
        cooperate_avg = cooperate_count / p2_choice_count

    if cooperate_avg > perc:
        return cooperate
    else:
        return defect

def strategy_opponentCooperate10Percentage(p1_history, p2_history):
    return strategy_opponentCooperatePercentage(0.10, p1_history, p2_history)

def strategy_opponentCooperate50Percentage(p1_history, p2_history):
    return strategy_opponentCooperatePercentage(0.50, p1_history, p2_history)

def strategy_opponentCooperate90Percentage(p1_history, p2_history):
    return strategy_opponentCooperatePercentage(0.90, p1_history, p2_history)

def strategy_random50(p1_history, p2_history):
    return random.choice([cooperate, defect])

def strategy_JamesCReed(p1_history, p2_history):
    """copy opponents last move unless they keep defecting"""
    if len(p1_history) == 0:
        return cooperate
    
    # last 3 values all defect then defect
    if len(p2_history) >= 3 and p2_history[-3:] == [defect, defect, defect]:
        return defect
    
    # regular return previous choice
    return p2_history[-1]

# A list of all strategy functions.
strategies = [
    strategy_alwaysCooperate,
    strategy_alwaysDefect,
    strategy_probAndLock,
    strategy_continuousProbe,
    strategy_defectUntilCooperate,
    strategy_opponentCooperate10Percentage,
    strategy_opponentCooperate50Percentage,
    strategy_opponentCooperate90Percentage,
    strategy_random50,
    strategy_JamesCReed
]

def main(num_of_iterations, num_of_strategies):
    """Main Game Loop"""
    print(f"num_of_iterations = {num_of_iterations}, num_of_strategies = {num_of_strategies}\n")

    scoreboard = [0] * num_of_strategies

    for p1 in range(num_of_strategies):
        # start after p1 till the num of strats 
        for p2 in range(p1 + 1, num_of_strategies):
            # track each players history and score 
            p1_score, p1_history, p2_score, p2_history = 0, [], 0, []

            # get strategy function names from strategies array
            p1_strategy, p2_strategy = strategies[p1], strategies[p2]

            for i in range(num_of_iterations):
                # choice -> reward -> score -> tracker
                p1_choice = p1_strategy(p1_history, p2_history)
                p2_choice = p2_strategy(p2_history, p1_history)

                reward_tuple = get_reward_values(p1_choice, p2_choice)

                p1_score += reward_tuple[0]
                p2_score += reward_tuple[1]

                p1_history.append(p1_choice)
                p2_history.append(p2_choice)

            # scoreboard
            scoreboard[p1] += p1_score
            scoreboard[p2] += p2_score

    # display results 
    for i in range(len(scoreboard)):
        strat_name = strategies[i].__name__.replace('strategy_', '')
        print(f"{strat_name}: {scoreboard[i]}")

if __name__ == "__main__":
    if len(sys.argv) == 3:
        num_of_iterations = int(sys.argv[1])
        num_of_strategies = int(sys.argv[2])
    elif len(sys.argv) == 2:
        num_of_iterations = int(sys.argv[1])

    main(num_of_iterations, num_of_strategies)