"""
Name: James Reed
Date: 10/10/25
Assignment: 3
Due Date: 10/13/25
About this project: This program refactors the 2D Simulation of Prisoners Dilemma from a sequential to parallel execution 
Assumptions: assumes no more than 3 args gridSize, steps, and nprocs
All work below was performed solely by Jimmy.
I used code generated by an AI tool.
"""

import sys

# Payoff matrix
# payoff[player_action][opponent_action]
payoffMatrix = [
    [3, 0],
    [5, 1],
]

gridSize = 10
steps = 10
nprocs_opt = None

if (len(sys.argv) > 1):
    gridSize = int(sys.argv[1])

if (len(sys.argv) > 2):
    steps = int(sys.argv[2])

if (len(sys.argv) > 3):
    nprocs_opt = int(sys.argv[3])
    
cooperate = 0
defect = 1

# Initialize the grid with random strategies: 'C' or 'D'

def initializeActionGrid1(size):
    global actionGrid
    for i in range(size):
        for j in range(size):
            if i < size / 2: 
                actionGrid[i][j] = cooperate
            else:
                actionGrid[i][j] = defect

def initializeActionGrid2(size):
    global actionGrid
    for i in range(size):
        for j in range(size):
            if i == j:
                actionGrid[i][j] = defect
            else: 
                actionGrid[i][j] = cooperate

def initializeActionGrid3(size):
    global actionGrid
    for i in range(size):
        for j in range(size):
            actionGrid[i][j] = cooperate

    actionGrid[int (size / 2)][int(size / 2)] = defect

def initializeActionGrid4(size):
    global actionGrid
    for i in range(size):
        for j in range(size):
            actionGrid[i][j] = cooperate

    if (size > 1):
         actionGrid[1][1] = defect
    else:
        actionGrid[0][0] = defect

# ------------------------------------------------------

import multiprocessing as mp

def split_bounds(nrows, nprocs):
    size = (nrows + nprocs - 1) // nprocs
    bounds = []
    for i in range(nprocs):
        s = i * size
        e = min(nrows, s + size)
        if s < e:
            bounds.append((s, e))
    return bounds

def init_action_value(init_id, n, i, j):
    if init_id == 1:
        return 0 if i < (n / 2) else 1
    elif init_id == 2:
        return 1 if i == j else 0
    elif init_id == 3:
        if i == (n // 2) and j == (n // 2):
            return 1
        return 0
    elif init_id == 4:
        if n > 1:
            return 1 if (i == 1 and j == 1) else 0
        else:
            return 1 if (i == 0 and j == 0) else 0
    else:
        return 0 if (i + j) % 2 == 0 else 1


def halo_worker(rank, start, end, N, nprocs, init_id, steps, act_down, act_up, rew_down, rew_up, result_queue):
    rows = end - start
    width = N

    act_curr = bytearray(rows * width)
    act_next = bytearray(rows * width)
    rew_curr = bytearray(rows * width)

    # local actions to process
    for i_local in range(rows):
        i = start + i_local
        base = i_local * width
        for j in range(width):
            act_curr[base + j] = init_action_value(init_id, N, i, j)

    has_up = (rank > 0)
    has_down = (rank + 1) < nprocs
    if has_up:
        q_act_from_up = act_down[rank - 1]  # from up neighbor
        q_act_to_up = act_up[rank - 1]      # to up neighbor
        q_rew_from_up = rew_down[rank - 1]
        q_rew_to_up = rew_up[rank - 1]
    if has_down:
        q_act_to_down = act_down[rank]      # to down neighbor
        q_act_from_down = act_up[rank]      # from down neighbor
        q_rew_to_down = rew_down[rank]
        q_rew_from_down = rew_up[rank]

    p = payoffMatrix

    for _step in range(steps):
        # exchange action rows
        if has_up:
            q_act_to_up.put(bytes(act_curr[0:width]))
        if has_down:
            q_act_to_down.put(bytes(act_curr[(rows - 1) * width: rows * width]))
        top_act_halo = q_act_from_up.get() if has_up else None
        bot_act_halo = q_act_from_down.get() if has_down else None

        # compute rewards
        for i_local in range(rows):
            base = i_local * width
            im1 = (i_local - 1) * width
            ip1 = (i_local + 1) * width
            for j in range(width):
                a = act_curr[base + j]
                total = 0
                if i_local > 0:
                    total += p[a][act_curr[im1 + j]]
                elif has_up and top_act_halo is not None:
                    total += p[a][top_act_halo[j]]
                if i_local + 1 < rows:
                    total += p[a][act_curr[ip1 + j]]
                elif has_down and bot_act_halo is not None:
                    total += p[a][bot_act_halo[j]]
                if j + 1 < width:
                    total += p[a][act_curr[base + (j + 1)]]
                if j > 0:
                    total += p[a][act_curr[base + (j - 1)]]
                rew_curr[base + j] = total

        # exchange rows
        if has_up:
            q_rew_to_up.put(bytes(rew_curr[0:width]))
        if has_down:
            q_rew_to_down.put(bytes(rew_curr[(rows - 1) * width: rows * width]))
        top_rew_halo = q_rew_from_up.get() if has_up else None
        bot_rew_halo = q_rew_from_down.get() if has_down else None

        # update actions
        for i_local in range(rows):
            base = i_local * width
            im1 = (i_local - 1) * width
            ip1 = (i_local + 1) * width
            for j in range(width):
                best_reward = rew_curr[base + j]
                best_action = act_curr[base + j]

                if i_local > 0:
                    r = rew_curr[im1 + j]
                    if r > best_reward:
                        best_reward = r
                        best_action = act_curr[im1 + j]
                elif has_up and top_rew_halo is not None and top_act_halo is not None:
                    r = top_rew_halo[j]
                    if r > best_reward:
                        best_reward = r
                        best_action = top_act_halo[j]

                if i_local + 1 < rows:
                    r = rew_curr[ip1 + j]
                    if r > best_reward:
                        best_reward = r
                        best_action = act_curr[ip1 + j]
                elif has_down and bot_rew_halo is not None and bot_act_halo is not None:
                    r = bot_rew_halo[j]
                    if r > best_reward:
                        best_reward = r
                        best_action = bot_act_halo[j]

                if j + 1 < width:
                    idx_e = base + (j + 1)
                    r = rew_curr[idx_e]
                    if r > best_reward:
                        best_reward = r
                        best_action = act_curr[idx_e]
                if j > 0:
                    idx_w = base + (j - 1)
                    r = rew_curr[idx_w]
                    if r > best_reward:
                        best_reward = r
                        best_action = act_curr[idx_w]

                act_next[base + j] = best_action

        act_curr, act_next = act_next, act_curr

    result_queue.put(bytes(act_curr))


def run_sim_haloMP(initF, size=8, steps=10, fName='haloMP.txt', nprocs_opt=None):
    """uses top and bottom rows exchanged between adjacent workers to avoid whole grid copying"""

    ctx = mp.get_context('fork') if 'fork' in mp.get_all_start_methods() else mp.get_context()

    # Map initializer to an ID
    init_name = initF.__name__
    if 'Grid1' in init_name:
        init_id = 1
    elif 'Grid2' in init_name:
        init_id = 2
    elif 'Grid3' in init_name:
        init_id = 3
    elif 'Grid4' in init_name:
        init_id = 4
    else:
        init_id = 1

    N = size
    procs_requested = nprocs_opt if nprocs_opt is not None else mp.cpu_count()
    nprocs = max(1, min(procs_requested, N, 16))

    row_bounds = split_bounds(N, nprocs)

    # queues for neighbors
    act_down = [ctx.SimpleQueue() for _ in range(nprocs - 1)]
    act_up = [ctx.SimpleQueue() for _ in range(nprocs - 1)]
    rew_down = [ctx.SimpleQueue() for _ in range(nprocs - 1)]
    rew_up = [ctx.SimpleQueue() for _ in range(nprocs - 1)]

    procs = []
    result_queues = []
    for rank, (start, end) in enumerate(row_bounds):
        rq = ctx.SimpleQueue()
        result_queues.append(rq)

        p = ctx.Process(target=halo_worker, args=(rank, start, end, N, nprocs, init_id, steps,
                                                  act_down, act_up, rew_down, rew_up, rq))
        p.daemon = False
        procs.append(p)

    for p in procs:
        p.start()

    slices = []
    for rank in range(len(procs)):
        slices.append(result_queues[rank].get())

    for p in procs:
        p.join()

    # Reassemble and write file
    actionGrid = [[0] * N for _ in range(N)]
    out_row = 0
    for (start, end), blob in zip(row_bounds, slices):
        rows = end - start
        for i_local in range(rows):
            row = list(blob[i_local * N:(i_local + 1) * N])
            actionGrid[out_row] = row
            out_row += 1

    with open(fName, "w") as f:
        for i in range(N):
            f.write(f"{i}: {actionGrid[i]}\n")

# ------------------------------------------------------

if __name__ == '__main__':
    # by running this we can fork at the start which will reduce the overhead i believe 
    try:
        if 'fork' in mp.get_all_start_methods():
            try:
                mp.set_start_method('fork')
            except RuntimeError:
                pass
    except Exception:
        pass

    run_sim_haloMP(initF = initializeActionGrid1, size=gridSize, steps=steps, fName = f'output_grid1_{gridSize}_{steps}_MP.txt', nprocs_opt=nprocs_opt)
    run_sim_haloMP(initF = initializeActionGrid2, size=gridSize, steps=steps, fName = f'output_grid2_{gridSize}_{steps}_MP.txt', nprocs_opt=nprocs_opt)
    run_sim_haloMP(initF = initializeActionGrid3, size=gridSize, steps=steps, fName = f'output_grid3_{gridSize}_{steps}_MP.txt', nprocs_opt=nprocs_opt)
    run_sim_haloMP(initF = initializeActionGrid4, size=gridSize, steps=steps, fName = f'output_grid4_{gridSize}_{steps}_MP.txt', nprocs_opt=nprocs_opt)
